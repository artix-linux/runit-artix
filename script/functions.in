#!/bin/bash
# rc functions
#

# sanitize PATH (will be overridden later when /etc/profile is sourced but is useful for udev)
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

# clear the TZ envvar, so daemons always respect /etc/localtime
unset TZ

. /etc/profile.d/locale.sh

if [[ $1 == "start" ]]; then
	if [[ $STARTING ]]; then
		echo "A daemon is starting another daemon; this is unlikely to work as intended."
	else
		export STARTING=1
	fi
fi

# width:
calc_columns () {
	STAT_COL=80
	if [[ ! -t 1 ]]; then
		USECOLOR=""
	elif [[ -t 0 ]]; then
		# stty will fail when stdin isn't a terminal
		STAT_COL=$(stty size)
		# stty gives "rows cols"; strip the rows number, we just want columns
		STAT_COL=${STAT_COL##* }
	elif tput cols &>/dev/null; then
		# is /usr/share/terminfo already mounted, and TERM recognized?
		STAT_COL=$(tput cols)
	fi
	if (( STAT_COL == 0 )); then
		# if output was 0 (serial console), set default width to 80
		STAT_COL=80
		USECOLOR=""
	fi

	# we use 13 characters for our own stuff
	STAT_COL=$(( STAT_COL - 13 ))

	if [[ -t 1 ]]; then
		SAVE_POSITION="\e[s"
		RESTORE_POSITION="\e[u"
		DEL_TEXT="\e[$(( STAT_COL + 4 ))G"
	else
		SAVE_POSITION=""
		RESTORE_POSITION=""
		DEL_TEXT=""
	fi
}

calc_columns

# disable colors on broken terminals
TERM_COLORS=$(tput colors 2>/dev/null)
if (( $? != 3 )); then
	case $TERM_COLORS in
		*[!0-9]*) USECOLOR="";;
		[0-7])    USECOLOR="";;
		'')       USECOLOR="";;
	esac
fi
unset TERM_COLORS

# functions:

deltext() {
	printf "${DEL_TEXT}"
}

printhl() {
	printf "${C_OTHER}${PREFIX_HL} ${C_H1}${1}${C_CLEAR} \n"
}

printsep() {
	printf "\n${C_SEPARATOR}   ------------------------------\n"
}

stat_busy() {
	printf "${C_OTHER}${PREFIX_REG} ${C_MAIN}${1}${C_CLEAR} "
	printf "${SAVE_POSITION}"
	deltext
	printf "   ${C_OTHER}[${C_BUSY}busy${C_OTHER}]${C_CLEAR} "
}

stat_done() {
	deltext
	printf "   ${C_OTHER}[${C_DONE}done${C_OTHER}]${C_CLEAR} \n"
}

stat_fail() {
	deltext
	printf "   ${C_OTHER}[${C_FAIL}fail${C_OTHER}]${C_CLEAR} \n"
}

stat_die() {
	stat_fail
	exit ${1:-1}
}

status() {
	local quiet
	case $1 in
		-q)
			quiet=1
			;;&
		-v)
			# NOOP: supported for backwards compat
			shift
			;;
	esac
	stat_busy "$1"
	shift
	if (( quiet )); then
		"$@" &>/dev/null
	else
		"$@"
	fi
	local ret=$?
	(( ret == 0 )) && stat_done || stat_fail
	return $ret
}

#  usage : in_array( $needle, $haystack )
# return : 0 - found
#          1 - not found
in_array() {
	local needle=$1; shift
	local item
	for item; do
		[[ $item = "${needle}" ]] && return 0
	done
	return 1 # Not Found
}

add_daemon() {
	[[ -d @RCRUNDIR@ ]] || mkdir -p @RCRUNDIR@
	>| @RCRUNDIR@/"$1"
}

rm_daemon() {
	rm -f @RCRUNDIR@/"$1"
}

ck_daemon() {
	[[ ! -f @RCRUNDIR@/$1 ]]
}

# Check if $1 is a valid daemon name
have_daemon() {
	[[ -f @RCSVDIR@/$1 && -x @RCSVDIR@/$1 ]]
}

# Check if $1 is started at boot
ck_autostart() {
	local daemon
	for daemon in ${RC_SYSINIT[@]}; do
        local sv=${daemon#*-}
		[[ $1 = "${sv#@}" ]] && return 1
	done
	return 0
}

ck_failed() {
	[[ ! -f @RCRUNDIR@/failed/$1 ]]
}

add_failed() {
	[[ -d @RCRUNDIR@/failed ]] || mkdir -p @RCRUNDIR@/failed
	>| @RCRUNDIR@/failed/"$1"
}

rm_failed() {
	rm -f @RCRUNDIR@/failed/"$1"
}

check_root() {
    (( EUID == 0 )) && return
    if type -P sudo >/dev/null; then
        exec sudo -- "${orig_argv[@]}"
    else
        exec su root -c "$(printf ' %q' "${orig_argv[@]}")"
    fi
}

ck_sysinit(){
    local daemon
	for daemon in ${RC_SYSINIT[@]}; do
        local sv=${daemon#*-}
		[[ $1 = "${sv#@}" ]] && return 1
	done
	return 0
}

ck_shutdown(){
    local daemon
	for daemon in ${RC_SHUTDOWN[@]}; do
        local sv=${daemon#*-}
		[[ $1 = "${sv#@}" ]] && return 1
	done
	return 0
}

enable_auto(){
    local sv=${daemon#*-}
    if have_daemon "$sv"; then
        if [[ ! -e @RCDIR@/sysinit/$daemon ]];then
            stat_busy "Enable $sv autostart"
            ln -s @RCSVDIR@/$sv @RCDIR@/sysinit/$daemon || stat_die
            stat_done
        else
            stat_busy "$sv is already autostarted"
            stat_die
        fi
    fi
}

disable_auto(){
    local sv=${daemon#*-}
    if have_daemon "$sv"; then
        if [[ -e @RCDIR@/sysinit/$daemon ]];then
            stat_busy "Disable $sv autostart"
            rm @RCDIR@/sysinit/$daemon || stat_die
            stat_done
        else
            stat_busy "$sv is already not autostarted"
            stat_die
        fi
    fi
}

start_daemon() {
	have_daemon "$1" && @RCSVDIR@/"$1" start
}

stop_daemon() {
	have_daemon "$1" && @RCSVDIR@/"$1" stop
}

# Status functions
status_started() {
	deltext
	echo -ne "$C_OTHER[${C_STRT}started$C_OTHER]$C_CLEAR "
}

status_stopped() {
	deltext
	echo -ne "$C_OTHER[${C_STRT}stopped$C_OTHER]$C_CLEAR "
}

ck_status() {
	! ck_daemon "$1" && status_started || status_stopped
}

print_welcome() {
	# see os-release(5)
	. /etc/os-release

	echo " "
	printhl "${PRETTY_NAME}\n"
	printhl "${C_H2}${HOME_URL}"
	printsep
}

print_leave(){
    # avoid staircase effect
    stty onlcr
    echo " "
    printhl "Initiating shutdown\n"
    echo " "
}

run_sysinit(){
    # Prints distro name and URL
    print_welcome
    calc_columns

    for service in ${RC_SYSINIT[@]};do
        start_daemon "${service#*-}"
    done
}

run_shutdown(){
    print_leave

    for service in ${RC_SHUTDOWN[@]};do
        stop_daemon "${service#*-}"
    done
}

# Filesystem functions
# These can be overridden/reused for customizations like shutdown/loop-fsck.
NETFS="nfs,nfs4,smbfs,cifs,codafs,ncpfs,shfs,fuse,fuseblk,glusterfs,davfs,fuse.glusterfs"

# Check local filesystems
fsck_all() {
	if [[ -f /forcefsck ]] || in_array forcefsck $(< /proc/cmdline); then
		FORCEFSCK="-f"
	elif [[ -f /fastboot ]] || in_array fastboot $(< /proc/cmdline); then
		return 0
	elif [[ -e /run/initramfs/root-fsck ]]; then
		IGNORE_MOUNTED="-M"
	fi

	fsck -A -T -C${FSCK_FD} -a -t no${NETFS//,/,no},noopts=_netdev ${IGNORE_MOUNTED} -- ${FORCEFSCK}
}

# Single-user login and/or automatic reboot after fsck (if needed)
fsck_reboot() {
	# $1 = exit code returned by fsck
	# Ignore conditions 'FS errors corrected' and 'Cancelled by the user'
	(( ($1 | 33) == 33 )) && return 0
	if (( $1 & 2 )); then
		echo
		echo "********************** REBOOT REQUIRED *********************"
		echo "*                                                          *"
		echo "* The system will be rebooted automatically in 15 seconds. *"
		echo "*                                                          *"
		echo "************************************************************"
		echo
		sleep 15
	else
		echo
		echo "*****************  FILESYSTEM CHECK FAILED  ****************"
		echo "*                                                          *"
		echo "*  Please repair manually and reboot. Note that the root   *"
		echo "*  file system is currently mounted read-only. To remount  *"
		echo "*  it read-write, type: mount -o remount,rw /              *"
		echo "*  When you exit the maintenance shell, the system will    *"
		echo "*  reboot automatically.                                   *"
		echo "*                                                          *"
		echo "************************************************************"
		echo
		sulogin -p
	fi
	echo "Automatic reboot in progress..."
	umount -a
	mount -o remount,ro /
	reboot -f
	exit 0
}

# set colors
if [[ $USECOLOR != [nN][oO] ]]; then
	if tput setaf 0 &>/dev/null; then
		C_CLEAR=$(tput sgr0)                 # clear text
		C_MAIN=${C_CLEAR}$(tput bold)        # main text
		C_OTHER=${C_MAIN}$(tput setaf 4)     # prefix & brackets
		C_SEPARATOR=${C_MAIN}$(tput setaf 0) # separator
		C_BUSY=${C_CLEAR}$(tput setaf 6)     # busy
		C_FAIL=${C_MAIN}$(tput setaf 1)      # failed
		C_DONE=${C_MAIN}                     # completed
		C_BKGD=${C_MAIN}$(tput setaf 5)      # backgrounded
		C_STARTED=${C_MAIN}$(tput setaf 2)   # started
		C_H1=${C_MAIN}                       # highlight text 1
		C_H2=${C_MAIN}$(tput setaf 6)        # highlight text 2
	else
		C_CLEAR="\e[m"          # clear text
		C_MAIN="\e[;1m"         # main text
		C_OTHER="\e[1;34m"      # prefix & brackets
		C_SEPARATOR="\e[1;30m"  # separator
		C_BUSY="\e[;36m"        # busy
		C_FAIL="\e[1;31m"       # failed
		C_DONE=${C_MAIN}        # completed
		C_BKGD="\e[1;35m"       # backgrounded
		C_STARTED="\e[1;32m"    # started
		C_H1=${C_MAIN}          # highlight text 1
		C_H2="\e[1;36m"         # highlight text 2
	fi
fi

# prefixes:

PREFIX_REG="::"
PREFIX_HL=" >"

RC_SYSINIT=$(ls @RCDIR@/sysinit)
RC_SHUTDOWN=$(ls @RCDIR@/shutdown)
