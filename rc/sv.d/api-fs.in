#!/bin/bash

# sourcing our current rc.conf requires this to be a bash script
. @RCLIBDIR@/functions
. @RCDIR@/rc.conf

CGROUP_OPTS=nodev,noexec,nosuid

cgroup2_find_path(){
    if grep -qw cgroup2 /proc/filesystems; then
        case "${CGROUP_MODE:-hybrid}" in
            hybrid) printf "/sys/fs/cgroup/unified" ;;
            unified) printf "/sys/fs/cgroup" ;;
        esac
    fi
    return 0
}

cgroup1_base(){
    grep -qw cgroup /proc/filesystems || return 0
    if ! mountinfo -q /sys/fs/cgroup; then
        local opts="${CGROUP_OPTS},mode=755,size=${rc_cgroupsize:-10m}"
        mount -n -t tmpfs -o "${opts}" cgroup_root /sys/fs/cgroup
    fi

    if ! mountinfo -q /sys/fs/cgroup/openrc; then
        local agent="@RCLIBDIR@/cgroup-release-agent"
        mkdir /sys/fs/cgroup/openrc
        mount -n -t cgroup \
            -o none,${CGROUP_OPTS},name=openrc,release_agent="$agent" \
            openrc /sys/fs/cgroup/openrc
        printf 1 > /sys/fs/cgroup/openrc/notify_on_release
    fi
    return 0
}

cgroup1_controllers(){
    "${HAVE_CONTROLLER1:-yes}" && [ -e /proc/cgroups ]  &&
    grep -qw cgroup /proc/filesystems || return 0
    while read -r name _ _ enabled _; do
        case "${enabled}" in
            1)	mountinfo -q "/sys/fs/cgroup/${name}" && continue
                local x
                for x in $CGROUP_CONTROLLERS; do
                [ "${name}" = "blkio" ] && [ "${x}" = "io" ] &&
                    continue 2
                [ "${name}" = "${x}" ] &&
                continue 2
                done
                mkdir "/sys/fs/cgroup/${name}"
                mount -n -t cgroup -o "${CGROUP_OPTS},${name}" \
                    "${name}" "/sys/fs/cgroup/${name}"
                ;;
        esac
    done < /proc/cgroups
    return 0
}

cgroup2_base(){
    grep -qw cgroup2 /proc/filesystems || return 0
    local base
    base="$(cgroup2_find_path)"
    mkdir -p "${base}"
    mount -t cgroup2 none -o "${CGROUP_OPTS},nsdelegate" "${base}" 2> /dev/null ||
        mount -t cgroup2 none -o "${CGROUP_OPTS}" "${base}"
    return 0
}

cgroup2_controllers(){
    grep -qw cgroup2 /proc/filesystems || return 0
    local active cgroup_path x y
    cgroup_path="$(cgroup2_find_path)"
    [ -z "${cgroup_path}" ] && return 0
    [ -e "${cgroup_path}/cgroup.controllers" ] &&
    read -r active < "${cgroup_path}/cgroup.controllers"
    for x in ${CGROUP_CONTROLLERS}; do
        for y in ${active}; do
        [ "$x" = "$y" ] &&
            [ -e "${cgroup_path}/cgroup.subtree_control" ]&&
            echo "+${x}"  > "${cgroup_path}/cgroup.subtree_control"
        done
    done
    return 0
}

cgroups_hybrid(){
    cgroup1_base
    cgroup2_base
    cgroup2_controllers
    cgroup1_controllers
    return 0
}

cgroups_legacy(){
    cgroup1_base
    cgroup1_controllers
    return 0
}

cgroups_unified(){
    cgroup2_base
    cgroup2_controllers
    return 0
}

mount_cgroups(){
    case "${CGROUP_MODE:-hybrid}" in
        hybrid) cgroups_hybrid ;;
        legacy) cgroups_legacy ;;
        unified) cgroups_unified ;;
    esac
    return 0
}

mount_api_fs(){

    mountpoint -q /sys     || mount -t sysfs sys /sys -o nosuid,noexec,nodev
    mountpoint -q /sys/kernel/security || mount -n -t securityfs securityfs /sys/kernel/security
    [ -d /sys/firmware/efi ] && (mountpoint -q /sys/firmware/efi/efivars || mount -n -t efivarfs -o ro efivarfs /sys/firmware/efi/efivars)

    [ -d /sys/fs/cgroup ] && mount_cgroups

    mountpoint -q /dev     || mount -t devtmpfs dev /dev -o mode=0755,nosuid
    mkdir -p /dev/{pts,shm}
    mountpoint -q /dev/pts || mount -t devpts devpts /dev/pts -o mode=0620,gid=5,nosuid,noexec
    mountpoint -q /dev/shm || mount -t tmpfs shm /dev/shm -o mode=1777,nosuid,nodev

    mountpoint -q /proc    || mount -t proc proc /proc -o nosuid,noexec,nodev

    mountpoint -q /run     || mount -t tmpfs run /run -o mode=0755,nosuid,nodev

    findmnt / --options ro &>/dev/null || mount -o remount,ro /
}

umount_api_fs(){
    umount -r -a -t nosysfs,noproc,nodevtmpfs,notmpfs
}

case "$1" in
    start)
        stat_busy "Mounting api filesystems"
        mount_api_fs
        add_daemon api-fs
        stat_done
        ;;
    stop)
        stat_busy "Unounting api filesystems"
        umount_api_fs
        rm_daemon api-fs
        stat_done
        ;;
    *)
        echo "usage: $0 {start|stop}"
        exit 1
        ;;
esac
